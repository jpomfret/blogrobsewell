<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rationalise on Rob Sewell (aka SQL DBA With A Beard)</title><link>https://sqldbawithabeard.github.io/blogrobsewell/tags/rationalise/</link><description>Recent content in rationalise on Rob Sewell (aka SQL DBA With A Beard)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 20 Jul 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://sqldbawithabeard.github.io/blogrobsewell/tags/rationalise/index.xml" rel="self" type="application/rss+xml"/><item><title>Remove-SQLDatabaseSafely My First Contribution to DBATools</title><link>https://sqldbawithabeard.github.io/blogrobsewell/blog/remove-sqldatabasesafely-my-first-contribution-to-dbatools/</link><pubDate>Wed, 20 Jul 2016 00:00:00 +0000</pubDate><guid>https://sqldbawithabeard.github.io/blogrobsewell/blog/remove-sqldatabasesafely-my-first-contribution-to-dbatools/</guid><description>&lt;p>What is DBA Tools?&lt;/p>
&lt;blockquote>
&lt;p>A collection of modules for SQL Server DBAs. It initially started out as ‘sqlmigration’, but has now grown into a collection of various commands that help automate DBA tasks and encourage best practices.&lt;/p>
&lt;/blockquote>
&lt;p>You can read more about &lt;a class="link" href="https://dbatools.io" target="_blank" rel="noopener"
>here&lt;/a> and it is &lt;a class="link" href="https://github.com/ctrlbold/dbatools" target="_blank" rel="noopener"
>freely available for download on GitHub&lt;/a> I thoroughly recommend that &lt;a class="link" href="https://www.youtube.com/watch?v=PciYdDEBiDM" target="_blank" rel="noopener"
>you watch this quick video&lt;/a> to see just how easy it is to migrate an entire SQL instance in one command (&lt;a class="link" href="https://www.youtube.com/watch?v=kQYUrSlb0wg" target="_blank" rel="noopener"
>Longer session here&lt;/a> )&lt;/p>
&lt;p>Installing it is as easy as&lt;/p>
&lt;p>&lt;code>Install-Module dbatools&lt;/code>&lt;/p>
&lt;p>which will get you over 80 commands . Visit &lt;a class="link" href="https://dbatools.io/functions/" target="_blank" rel="noopener"
>https://dbatools.io/functions/&lt;/a> to find out more information about them&lt;/p>
&lt;p>&lt;a class="link" href="https://sqldbawithabeard.github.io/blogrobsewell/assets/uploads/2016/07/cmdlets.png" >&lt;img src="https://sqldbawithabeard.github.io/blogrobsewell/assets/uploads/2016/07/cmdlets.png"
loading="lazy"
alt="cmdlets"
>&lt;/a>&lt;/p>
&lt;p>The journey to &lt;code>Remove-SQLDatabaseSafely&lt;/code> started with William Durkin &lt;a class="link" href="http://williamdurkin.com/" target="_blank" rel="noopener"
>b&lt;/a> | &lt;a class="link" href="https://twitter.com/sql_williamd" target="_blank" rel="noopener"
>t&lt;/a> who presented to the &lt;a class="link" href="http://sqlsouthwest.co.uk/" target="_blank" rel="noopener"
>SQL South West User Group&lt;/a>  (&lt;a class="link" href="http://www.sqlsaturday.com/269/Sessions/Details.aspx?sid=28201" target="_blank" rel="noopener"
>You can get his slides here)&lt;/a>&lt;/p>
&lt;p>Following that session  I wrote a Powershell Script to gather information about the last used date for databases &lt;a class="link" href="https://sqldbawithabeard.github.io/blogrobsewell/rationalisation-of-database-with-powershell-and-t-sql-part-one/" >which I blogged about here&lt;/a> and then a T-SQL script to take a final backup and create a SQL Agent Job to restore from that back up &lt;a class="link" href="https://sqldbawithabeard.github.io/blogrobsewell/rationalisation-of-database-with-powershell-and-t-sql-part-two-2/" >which I blogged about here&lt;/a> The team have used this solution (updated to load the DBA Database and a report instead of using Excel) ever since and it proved invaluable when a read-only database was dropped and could quickly and easily be restored with no fuss.&lt;/p>
&lt;p>I was chatting with Chrissy LeMaire who founded DBATools &lt;a class="link" href="https://blog.netnerds.net/" target="_blank" rel="noopener"
>b&lt;/a> | &lt;a class="link" href="https://twitter.com/cl" target="_blank" rel="noopener"
>t&lt;/a> about this process and when she asked for contributions in the &lt;a class="link" href="https://sqlps.io/slack" target="_blank" rel="noopener"
>SQL Server Community Slack&lt;/a> I offered my help and she suggested I write this command. I have learnt so much. I thoroughly enjoyed and highly recommend working on projects collaboratively to improve your skills. It is amazing to work with such incredible professional PowerShell people.&lt;/p>
&lt;p>I went back to the basics and thought about what was required and watched one of my favourite videos again. &lt;a class="link" href="https://sqlps.io/backuprant" target="_blank" rel="noopener"
>Grant Fritcheys Backup Rant&lt;/a>&lt;/p>
&lt;p>I decided that the process should be as follows&lt;/p>
&lt;ol>
&lt;li>Performs a DBCC CHECKDB&lt;/li>
&lt;li>Database is backed up WITH CHECKSUM&lt;/li>
&lt;li>Database is restored with VERIFY ONLY on the source&lt;/li>
&lt;li>An Agent Job is created to easily restore from that backup&lt;/li>
&lt;li>The database is dropped&lt;/li>
&lt;li>The Agent Job restores the database&lt;/li>
&lt;li>performs a DBCC CHECKDB and drops the database for a final time&lt;/li>
&lt;/ol>
&lt;p>This (hopefully) passes all of Grants checks. This is how I created the command&lt;/p>
&lt;p>I check that the SQL Agent is running otherwise we wont be able to run the job. I use a while loop with a timeout like this&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$agentservice = Get-Service -ComputerName $ipaddr -Name $serviceName
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">if ($agentservice.Status -ne &amp;#39;Running&amp;#39;) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $agentservice.Start()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $timeout = new-timespan -seconds 60
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $sw = [diagnostics.stopwatch]::StartNew()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $agentstatus = (Get-Service -ComputerName $ipaddr -Name $serviceName).Status
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while ($dbStatus -ne &amp;#39;Running&amp;#39; -and $sw.elapsed -lt $timeout) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $dbStatus = (Get-Service -ComputerName $ipaddr -Name $serviceName).Status
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>There are a lot more checks and logic than I will describe here to make sure that the process is as robust as possible. For example, the script can exit after errors are found using DBCC CHECKDB or continue and label the database backup file and restore job appropriately. Unless the force option is used it will exit if the job name already exists. We have tried to think of everything but if something has been missed or you have suggestions let us know (details at end of post)&lt;/p>
&lt;p>The only thing I didn’t add was a LARGE RED POP UP SAYING ARE YOU SURE YOU WANT TO DROP THIS DATABASE but I considered it!!&lt;/p>
&lt;h2 id="performs-a-dbcc-checkdb">Performs a DBCC CHECKDB&lt;/h2>
&lt;p>Running DBCC CHECKDB with Powershell is as easy as this&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$sourceserver = New-Object Microsoft.SQLServer.Management.Smo.Server &amp;#34;ServerName&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$db = $sourceserver.databases[$dbname]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$null = $db.CheckTables(&amp;#39;None&amp;#39;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;a class="link" href="https://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.database.checktables.aspx" target="_blank" rel="noopener"
>you can read more on MSDN&lt;/a>&lt;/p>
&lt;h2 id="database-is-backed-up-with-checksum">Database is backed up WITH CHECKSUM&lt;/h2>
&lt;p>Stuart Moore is my go to for doing &lt;a class="link" href="http://stuart-moore.com/category/31-days-of-sql-server-backup-and-restore-with-powershell/" target="_blank" rel="noopener"
>backups and restores with SMO&lt;/a>&lt;/p>
&lt;p>I ensured that the backup was performed with checksum like this&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$backup = New-Object -TypeName Microsoft.SqlServer.Management.Smo.Backup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$backup.Action = [Microsoft.SqlServer.Management.SMO.BackupActionType]::Database
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$backup.BackupSetDescription = &amp;#34;Final Full Backup of $dbname Prior to Dropping&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$backup.Database = $dbname
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$backup.Checksum = $True
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="database-is-restored-with-verify-only-on-the-source">Database is restored with VERIFY ONLY on the source&lt;/h2>
&lt;p>I used SMO all the way through this command and performed the restore verify only like this&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$restoreverify = New-Object &amp;#39;Microsoft.SqlServer.Management.Smo.Restore&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$restoreverify.Database = $dbname
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$restoreverify.Devices.AddDevice($filename, $devicetype)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$result = $restoreverify.SqlVerify($sourceserver)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="an-agent-job-is-created-to-easily-restore-from-that-backup">An Agent Job is created to easily restore from that backup&lt;/h2>
&lt;p>First I created a category for the Agent Job&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Function New-SqlAgentJobCategory {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> param ([string]$categoryname,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [object]$jobServer)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (!$jobServer.JobCategories[$categoryname]) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if ($Pscmdlet.ShouldProcess($sourceserver, &amp;#34;Creating Agent Job Category $categoryname&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Write-Output &amp;#34;Creating Agent Job Category $categoryname&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $category = New-Object Microsoft.SqlServer.Management.Smo.Agent.JobCategory
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $category.Parent = $jobServer
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $category.Name = $categoryname
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $category.Create()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Write-Output &amp;#34;Created Agent Job Category $categoryname&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> catch {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Write-Exception $_
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> throw &amp;#34;FAILED : To Create Agent Job Category $categoryname - Aborting&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>and then generated the TSQL for the restore step by using the &lt;a class="link" href="https://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.restore.script.aspx" target="_blank" rel="noopener"
>script method on the Restore SMO object&lt;/a>&lt;/p>
&lt;p>This is how to create an Agent Job&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$job = New-Object Microsoft.SqlServer.Management.Smo.Agent.Job $jobServer, $jobname
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$job.Name = $jobname
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$job.OwnerLoginName = $jobowner
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$job.Description = &amp;#34;This job will restore the $dbname database using the final backup located at $filename&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>and then to add a job step to run the restore command&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$jobStep = new-object Microsoft.SqlServer.Management.Smo.Agent.JobStep $job, $jobStepName $jobStep.SubSystem = &amp;#39;TransactSql&amp;#39; # &amp;#39;PowerShell&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$jobStep.DatabaseName = &amp;#39;master&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$jobStep.Command = $jobStepCommmand
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$jobStep.OnSuccessAction = &amp;#39;QuitWithSuccess&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$jobStep.OnFailAction = &amp;#39;QuitWithFailure&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">if ($Pscmdlet.ShouldProcess($destination, &amp;#34;Creating Agent JobStep on $destination&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $null = $jobStep.Create()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $job.ApplyToTargetServer($destination)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $job.StartStepID = $jobStartStepid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $job.Alter()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="the-database-is-dropped">The database is dropped&lt;/h2>
&lt;p>We try 3 different methods to drop the database&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$server.KillDatabase($dbname)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$server.databases[$dbname].Drop()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$null = $server.ConnectionContext.ExecuteNonQuery(&amp;#34;DROP DATABASE &amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="the-agent-job-restores-the-database">The Agent Job restores the database&lt;/h2>
&lt;p>To run the Agent Job I call the start method of the Job SMO Object&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> $job = $destserver.JobServer.Jobs[$jobname]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $job.Start()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $status = $job.CurrentRunStatus
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while ($status -ne &amp;#39;Idle&amp;#39;) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Write-Output &amp;amp;quot; Restore Job for $dbname on $destination is $status&amp;amp;quot;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $job.Refresh()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $status = $job.CurrentRunStatus
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Start-Sleep -Seconds 5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Then we drop the database for the final time with the confidence that we have a safe backup and an easy one click method to restore it from that backup (as long as the backup is in the same location)&lt;/p>
&lt;p>There are further details on the &lt;a class="link" href="https://dbatools.io/functions/remove-sqldatabasesafely/" target="_blank" rel="noopener"
>functions page on dbatools&lt;/a>&lt;/p>
&lt;p>Some videos of it in action are on YouTube &lt;a class="link" href="http://dbatools.io/video" target="_blank" rel="noopener"
>http://dbatools.io/video&lt;/a>&lt;/p>
&lt;p>You can take a look at &lt;a class="link" href="https://github.com/ctrlbold/dbatools/blob/fbd2f19b4442a8065f3cb133d385fde9b2cddea0/functions/Remove-SqlDatabaseSafely.ps1" target="_blank" rel="noopener"
>the code on GitHub here&lt;/a>&lt;/p>
&lt;p>You can install it with&lt;/p>
&lt;p>&lt;code>Install-Module dbatools&lt;/code>&lt;/p>
&lt;p>You can provide feedback via the &lt;a class="link" href="https://dbatools.io/trello" target="_blank" rel="noopener"
>Trello Board&lt;/a> or discuss it in the #dbatools channel in the &lt;a class="link" href="https://sqlps.io/slack" target="_blank" rel="noopener"
>Sqlserver Community Slack&lt;/a>&lt;/p>
&lt;p>You too can also become a contributor &lt;a class="link" href="https://dbatools.io/join-us/" target="_blank" rel="noopener"
>https://dbatools.io/join-us/&lt;/a> Come and write a command to make it easy for DBAs to (this bit is up to your imagination).&lt;/p></description></item><item><title>Rationalisation of Database with Powershell and T-SQL part two</title><link>https://sqldbawithabeard.github.io/blogrobsewell/blog/rationalisation-of-database-with-powershell-and-t-sql-part-two/</link><pubDate>Mon, 03 Mar 2014 00:00:00 +0000</pubDate><guid>https://sqldbawithabeard.github.io/blogrobsewell/blog/rationalisation-of-database-with-powershell-and-t-sql-part-two/</guid><description>&lt;img src="https://sqldbawithabeard.github.io/blogrobsewell/assets/uploads/2014/03/030314_2100_rationalisa1.png" alt="Featured image of post Rationalisation of Database with Powershell and T-SQL part two" />&lt;p>In the &lt;a class="link" href="https://blog.robsewell.com/rationalisation-of-database-with-powershell-and-t-sql-part-one/" target="_blank" rel="noopener"
>previous post&lt;/a> I showed the script to create an Excel Workbook, colour coded showing the last used date for all of the databases on servers in my sqlservers.txt file. After gathering that information over several months, there is then a requirement for someone to make a decision as to which databases can be removed.&lt;/p>
&lt;p>Obviously there will be some databases that are read-only or if not set specifically as read-only may only be used for reference without data being added. You should hopefully have knowledge of these databases and be able to take them off the list quickly.&lt;/p>
&lt;p>There are other challenges for a DBA to overcome prior to any action. Many questions need to be answered such as&lt;/p>
&lt;p>Who owns the database?&lt;br>
Who is the service owner responsible for the service/application in use by the database?&lt;br>
Even though they may be the service owner who will ultimately sign off permission to remove the database are they aware of how important it is for their people? Or what times of the year it is important to them?&lt;br>
You may find test and development databases that have not been used for months but will they be required next week?&lt;br>
Is it important enough for them to take the time to give the permission?&lt;/p>
&lt;p>And plenty more… Add some in the comments below.&lt;/p>
&lt;p>Our &lt;a class="link" href="http://www.johnsansom.com/the-database-administrators-primary-responsibility/" target="_blank" rel="noopener"
>Primary responsibility&lt;/a> is the data. We need to be able to ensure that the data is safe and can be made available quickly and easily. In this situation we need to have a valid backup and a quick and easy method of restoring it. I chose to solve this by creating a T-SQL script which will :-&lt;/p>
&lt;ul>
&lt;li>Perform a &lt;a class="link" href="http://technet.microsoft.com/en-us/library/ms176064.aspx" target="_blank" rel="noopener"
>DBCC CHECKDB&lt;/a> on the database&lt;/li>
&lt;li>&lt;a class="link" href="http://technet.microsoft.com/en-us/library/ms187893.aspx" target="_blank" rel="noopener"
>Backup the database with CHECKSUM&lt;/a>&lt;/li>
&lt;li>Perform a &lt;a class="link" href="http://technet.microsoft.com/en-us/library/ms188902.aspx" target="_blank" rel="noopener"
>VERIFY ONLY&lt;/a> restore of the database&lt;/li>
&lt;li>Drop the database&lt;/li>
&lt;li>Create an agent job to restore the database from that backup&lt;/li>
&lt;/ul>
&lt;p>The reasoning for these steps is best explained by watching &lt;a class="link" href="http://www.youtube.com/watch?v=Ah0jabU9G8o" target="_blank" rel="noopener"
>this video&lt;/a> and yes I always perform the last step too J&lt;/p>
&lt;p>I could have used PowerShell to do this by examining The SMO for the Server and the JobServer but this time I decided to challenge myself by writing it in T-SQL as I am weaker in that area. The script below is the result of that work. It works for me. I expect that there are other ways of doing this and please feel free to point out any errors or suggestions. That is how I learn. Hopefully these posts will be of use to other DBAs like myself.&lt;/p>
&lt;p>As always with anything you read on the internet. Validate and test. This script works for me on SQL Servers 2005, 2008,2008R2 and 2012 but if you are thinking of running it in your own Production Environment – DON’T.&lt;/p>
&lt;p>Well not until you have tested it somewhere safe first J&lt;/p>
&lt;p>The first challenge I encountered was that I wanted to only have to change the name of the database to be able to run the script and perform all of these steps. That will also lead onto a stored procedure and then I can automate more of this process and schedule at times to suit the database servers as well. I accomplished this by using a temp table and populating it with the variables I will need as shown below&lt;/p>
&lt;pre>&lt;code>-- Drop temp table if it exists
IF OBJECT_ID('tempdb..#vars') IS NOT NULL
DROP TABLE #vars
-- Create table to hold global variable
create table #vars (DBName nvarchar(50), PATH nvarchar(300),DataName nvarchar(50),LogName nvarchar (50),DataLoc nvarchar (256),LogLoc nvarchar (256))
insert into #vars (DBName) values ('DATABASENAME')
-- Declare and set variables
DECLARE @PATH nvarchar(300)
Set @Path = (SELECT 'PATH TO RATIONALISATION FOLDER WITH TRAILING SLASH' + @DBName + '_LastGolden_' + + convert(varchar(50),GetDate(),112) + '.bak' )
DECLARE @DataName nvarchar(50)
Set @DataName = (SELECT f.name
FROM sys.master_files F
join sys.databases D
on&amp;amp;amp;nbsp;d.database_id = f.database_id
WHERE F.type = 0
AND d.Name = @DBNAME)
-- Print @DataName
DECLARE @LogName nvarchar (50)
Set @LogName = (SELECT f.name
FROM sys.master_files F
join sys.databases D
on&amp;amp;amp;nbsp;d.database_id = f.database_id
WHERE F.type = 1
AND d.Name = @DBNAME)
-- PRINT @LogName
Declare @DataLoc nvarchar (256)
Set @DataLoc = (SELECT f.physical_name
FROM sys.master_files F
join sys.databases D
on&amp;amp;amp;nbsp;d.database_id = f.database_id
WHERE F.type = 0
AND d.Name = @DBNAME)
--Print @DataLoc
Declare @LogLoc nvarchar (256)
Set @LogLoc = (SELECT f.physical_name
FROM sys.master_files F
join sys.databases D
on&amp;amp;amp;nbsp;d.database_id = f.database_id
WHERE F.type = 1
AND d.Name = @DBNAME)
--Print @LogLoc
update #vars Set PATH = @PATH
update #vars Set DataName = @DataName
update #vars Set LogName = @LogName
update #vars Set DataLoc = @DataLoc
update #vars Set LogLoc = @LogLoc
-- Select * from #vars
&lt;/code>&lt;/pre>
&lt;p>I then use the variables throughout the script by selecting them from the temp table as follows&lt;/p>
&lt;pre>&lt;code>DECLARE @DBName nvarchar(50)
Set @DBName = (Select DBNAme from #vars)&amp;amp;lt;code&amp;amp;gt;
&lt;/code>&lt;/pre>
&lt;p>And using the variables to create and execute the T-SQL for each of the steps above.&lt;/p>
&lt;p>It is pointless to move onto the next step of the previous one has failed so I created some error handling as follows&lt;/p>
&lt;pre>&lt;code>if @@error != 0 raiserror('Rationalisation Script failed at Verify Restore', 20, -1) with log
GO
&lt;/code>&lt;/pre>
&lt;p>I created the T-SQL for the agent job by first creating the restore script and adding it to a variable and then right-clicking on a previously created restore database job and using the script to new window command&lt;/p>
&lt;p>&lt;img src="https://blog.robsewell.com/assets/uploads/2014/03/030314_2100_rationalisa1.png"
loading="lazy"
>&lt;/p>
&lt;p>It was then a case of adding single quotes and reading the code until it would successfully run&lt;/p>
&lt;pre>&lt;code>/***
Rationalisation Script
Script to Automatically Backup, Drop and create Agent Job to restore from that backup
AUTHOR - Rob Sewell https://blog.robsewell.com
DATE - 19/01/2014
USAGE - You need to Change the Database Name after &amp;quot; insert #vars values (' &amp;quot;
You also need to check that the folder after &amp;quot; Set @Path = (SELECT ' &amp;quot; is correct and exists
and Find and replace both entries for THEBEARD\Rob with the account that will be the owner of the job and the database owner
Once this has been run AND you have checked that it has successfully backed up the database and created the job and you have checked hte job works
You may delete the backups but keep the backup folder under UserDbs
***/
--Drop temp table if it exists
IF OBJECT_ID('tempdb..#vars') IS NOT NULL
DROP TABLE #vars
--Create table to hold global variable
create table #vars (DBName nvarchar(50), PATH nvarchar(300),DataName nvarchar(50),LogName nvarchar (50),DataLoc nvarchar (256),LogLoc nvarchar (256))
insert into #vars (DBName) values ('SQL2012Ser2012DB'
)
--Declare and set variables
DECLARE @DBName nvarchar(50)
Set @DBName = (Select DBNAme from #vars)
DECLARE @PATH nvarchar(300)
Set @Path = (SELECT 'PATH TO RATIONALISATION FOLDER' + @DBName + '_LastGolden_' + + convert(varchar(50),GetDate(),112) + '.bak' )
DECLARE @DataName nvarchar(50)
Set @DataName = (SELECT f.name
FROM sys.master_files F
join sys.databases D
on
d.database_id = f.database_id
WHERE F.type = 0
AND d.Name = @DBNAME)
--Print @DataName
DECLARE @LogName nvarchar (50)
Set @LogName = (SELECT f.name
FROM sys.master_files F
join sys.databases D
on
d.database_id = f.database_id
WHERE F.type = 1
AND d.Name = @DBNAME)
--PRINT @LogName
Declare @DataLoc nvarchar (256)
Set @DataLoc = (SELECT f.physical_name
FROM sys.master_files F
join sys.databases D
on
d.database_id = f.database_id
WHERE F.type = 0
AND d.Name = @DBNAME)
--Print @DataLoc
Declare @LogLoc nvarchar (256)
Set @LogLoc = (SELECT f.physical_name
FROM sys.master_files F
join sys.databases D
on
d.database_id = f.database_id
WHERE F.type = 1
AND d.Name = @DBNAME)
--Print @LogLoc
update #vars Set PATH = @PATH
update #vars Set DataName = @DataName
update #vars Set LogName = @LogName
update #vars Set DataLoc = @DataLoc
update #vars Set LogLoc = @LogLoc
-- Select * from #vars
-- DBCC
DECLARE @DBCCSQL nvarchar (4000)
SET @DBCCSQL = '
USE [' + @DBName + ']
DBCC CHECKDB WITH NO_INFOMSGS, ALL_ERRORMSGS
'
-- Print @DBCCSQL
EXECUTE(@DBCCSQL)
-- Break out if error raised We need to do some work if there are errors here
if @@error != 0 raiserror('Rationalisation Script failed at DBCC', 20, -1) with log
GO
-- Declare and set variables
DECLARE @DBName nvarchar(50)
Set @DBName = (Select DBNAme from #vars)
DECLARE @PATH nvarchar(300)
Set @Path = (SELECT PATH from #vars)
Declare @BKUPName nvarchar(300)
Set @BKUPName = (SELECT 'Last Golden Backup For ' + @DBName + '- Full Database Backup')
DECLARE @BackupSQL nvarchar (4000)
SET @BackupSQL = '
BACKUP DATABASE [' + @DBName + '] TO DISK = N''' + @PATH + '''
WITH INIT, NAME = N''' + @BKUPName + ''',
CHECKSUM, STATS = 10
'
--- PRINT @BackupSQL
-- Backup database to Golden backup location
EXECUTE(@BackupSQL)
GO
-- Break Out if there are errors here - If there is no backup we don't want to continue
if @@error != 0 raiserror('Rationalisation Script failed at Backup', 20, -1) with log
GO
DECLARE @PATH nvarchar(300)
Set @Path = (SELECT PATH from #vars)
RESTORE VERIFYONLY
FROM DISK = @PATH;
if @@error != 0 raiserror('Rationalisation Script failed at Verify Restore', 20, -1) with log
GO
-- Declare variables for dropping database
DECLARE @DBName nvarchar(50)
Set @DBName = (Select DBNAme from #vars)
DECLARE @DROPSQL nvarchar (4000)
SET @DROPSQL = '
USE [master]
ALTER DATABASE [' + @DBName + '] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
DROP DATABASE [' + @DBName + ']
'
-- PRINT @DROPSQL
--Drop database
EXECUTE(@DROPSQL)
GO
if @@error != 0 raiserror('Rationalisation Script failed at Drop Database', 20, -1) with log
GO
--Declare variables for creating Job
DECLARE @DBName nvarchar(50)
Set @DBName = (Select DBNAme from #vars)
DECLARE @PATH nvarchar(300)
Set @Path = (Select PATH from #vars)
DECLARE @DataName nvarchar(50)
Set @DataName = (Select DataName from #vars)
DECLARE @LogName nvarchar (50)
Set @LogName = (Select LogName from #vars)
Declare @DataLoc nvarchar (256)
Set @DataLoc = (Select DataLoc from #vars)
Declare @LogLoc nvarchar (256)
Set @LogLoc = (Select LogLoc from #vars)
DECLARE @RestoreCommand nvarchar(4000)
Set @RestoreCommand = '''RESTORE DATABASE [' + @DBName + ']
FROM DISK = N''''' + @PATH + '''''
WITH FILE = 1,
MOVE N''''' + @DataName + ''''' TO N''''' + @DataLoc + ''''',
MOVE N''''' + @LogName + ''''' TO N''''' + @LogLoc + ''''',
NOUNLOAD, REPLACE, STATS = 10
'''
--print @RestoreCommand
--Create Job creation tsql
DECLARE @JOBSQL nvarchar (4000)
SET @JOBSQL = 'USE [msdb]
BEGIN TRANSACTION
DECLARE @ReturnCode INT
SELECT @ReturnCode = 0
/****** Object: JobCategory [[Uncategorized (Local)]]] Script Date: 01/18/2014 14:12:04 ******/
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N''[Uncategorized (Local)]'' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N''JOB'', @type=N''LOCAL'', @name=N''[Uncategorized (Local)]''
IF (@@ERROR &amp;amp;lt;&amp;amp;gt; 0 OR @ReturnCode &amp;amp;lt;&amp;amp;gt; 0) GOTO QuitWithRollback
END
DECLARE @JOBNAME nvarchar(300)
set @JOBNAME = ''Rationlised - - Restore ' + @DBName + ' from Last Golden Backup''
Declare @JobDesc nvarchar(300)
Set @JobDesc = '' Rationalised Database Restore Script for ' + @DBName + '''
DECLARE @jobId BINARY(16)
EXEC @ReturnCode = msdb.dbo.sp_add_job @job_name= @JOBNAME,
@enabled=1,
@notify_level_eventlog=0,
@notify_level_email=0,
@notify_level_netsend=0,
@notify_level_page=0,
@delete_level=0,
@description=@JobDesc,
@category_name=N''[Uncategorized (Local)]'',
@owner_login_name=N''THEBEARD\Rob'', @job_id = @jobId OUTPUT
IF (@@ERROR &amp;amp;lt;&amp;amp;gt; 0 OR @ReturnCode &amp;amp;lt;&amp;amp;gt; 0) GOTO QuitWithRollback
/****** Object: Step [Restore Database] Script Date: 01/18/2014 14:12:04 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N''Restore Database'',
@step_id=1,
@cmdexec_success_code=0,
@on_success_action=3,
@on_success_step_id=0,
@on_fail_action=2,
@on_fail_step_id=0,
@retry_attempts=0,
@retry_interval=0,
@os_run_priority=0, @subsystem=N''TSQL'',
@command= ' + @RestoreCommand + ',
@database_name=N''master'',
@flags=4
/****** Object: Step [Set Owner] Script Date: 01/19/2014 10:14:57 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N''Set Owner'',
@step_id=2,
@cmdexec_success_code=0,
@on_success_action=1,
@on_success_step_id=0,
@on_fail_action=2,
@on_fail_step_id=0,
@retry_attempts=0,
@retry_interval=0,
@os_run_priority=0, @subsystem=N''TSQL'',
@command=N''USE [' + @DBName + ']
EXEC sp_changedbowner @loginame = N''''THEBEARD\Rob'''', @map = false'',
@database_name=N''master'',
@flags=0
IF (@@ERROR &amp;amp;lt;&amp;amp;gt; 0 OR @ReturnCode &amp;amp;lt;&amp;amp;gt; 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR &amp;amp;lt;&amp;amp;gt; 0 OR @ReturnCode &amp;amp;lt;&amp;amp;gt; 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N''(local)''
IF (@@ERROR &amp;amp;lt;&amp;amp;gt; 0 OR @ReturnCode &amp;amp;lt;&amp;amp;gt; 0) GOTO QuitWithRollback
COMMIT TRANSACTION
GOTO EndSave
QuitWithRollback:
IF (@@TRANCOUNT &amp;amp;gt; 0) ROLLBACK TRANSACTION
EndSave:
'
--PRINT @JOBSQL
--Create Agent Job
EXECUTE(@JOBSql)
if @@error != 0 raiserror('Rationalisation Script failed at Create Job', 20, -1) with log
GO
DROP Table #vars
&lt;/code>&lt;/pre>
&lt;p>The process I have used is to change the database name in the script and run it and then run the Agent Job and check the database has been created. Then and only then can I drop the database and disable any jobs for the database. Yes that was the last step in the video J as Grant says “a file is just a file, a backup is a restored database”&lt;/p>
&lt;p>Using this script you can reduce the footprint and load on your servers by removing unneeded or unused databases whilst still guaranteeing that should there be a requirement for them you KNOW you can easily restore them. You will still need to take some additional steps like adding a stop to the Agent Job to recreate any users and any other jobs that the database needs but that is more specific to your environment and you will be best placed to achieve this&lt;/p></description></item><item><title>Rationalisation of Database with Powershell and T-SQL part one</title><link>https://sqldbawithabeard.github.io/blogrobsewell/blog/rationalisation-of-database-with-powershell-and-t-sql-part-one/</link><pubDate>Tue, 25 Feb 2014 00:00:00 +0000</pubDate><guid>https://sqldbawithabeard.github.io/blogrobsewell/blog/rationalisation-of-database-with-powershell-and-t-sql-part-one/</guid><description>&lt;img src="https://sqldbawithabeard.github.io/blogrobsewell/assets/uploads/2014/02/usage-excel.jpg" alt="Featured image of post Rationalisation of Database with Powershell and T-SQL part one" />&lt;p>I have recently been involved in a project to rationalise databases. It is easy in a large organisation for database numbers to rapidly increase and sometimes the DBA may not be aware of or be able to control the rise if they don’t have knowledge of all of the database servers on the estate.&lt;/p>
&lt;p>There are lots of benefits of rationalisation to the business. Reduced cpu usage = reduced heat released = lower air-con bill for the server room and less storage used = quicker backups and less tapes used or better still less requirement for that expensive new SAN. You may be able to consolidate data and provide one version of the truth for the business as well. Removing servers can release licensing costs which could then be diverted elsewhere or pay for other improvements.&lt;/p>
&lt;p>William Durkin &lt;a class="link" href="http://williamdurkin.com/" target="_blank" rel="noopener"
>b&lt;/a>  &lt;a class="link" href="https://twitter.com/sql_williamd" target="_blank" rel="noopener"
>t&lt;/a> presented to the &lt;a class="link" href="http://sqlsouthwest.co.uk" target="_blank" rel="noopener"
>SQL South West User Group&lt;/a> about this and will be doing the session at SQL Saturday in Exeter in March 2014 Please check out his session for a more detailed view&lt;/p>
&lt;p>I needed to be able to identify databases that could possibly be deleted and realised that an easy way to achieve this would be to use a script to check for usage of the database.&lt;/p>
&lt;p>No need to recreate the wheel so I went to Aaron Bertrands blog &lt;a class="link" href="http://sqlblog.com/blogs/aaron_bertrand/archive/2008/05/06/when-was-my-database-table-last-accessed.aspx" target="_blank" rel="noopener"
>http://sqlblog.com/blogs/aaron_bertrand/archive/2008/05/06/when-was-my-database-table-last-accessed.aspx&lt;/a> and used his script. Instead of using an audit file I decided to use Powershell so that I could output the results to Excel and colour code them. This made it easier to check the results and also easier to show to Managers and Service Owners&lt;/p>
&lt;pre>&lt;code>#################################################################################
# NAME: lastdbusage.ps1
# AUTHOR: Rob Sewell
# https://blog.robsewell.com
# DATE:19/10/2013
#
# COMMENTS: Fill Excel WorkBook with details fo last access times for each database
#
# NOTES : Does NOT work with SQL 2000 boxes
$FileName = '' # Set a filename for the output
# Get List of sql servers to check
$sqlservers = Get-Content '' # serverlist, database query whatever
# Set SQL Query
$query = &amp;quot;WITH agg AS
(
SELECT
max(last_user_seek) last_user_seek,
max(last_user_scan) last_user_scan,
max(last_user_lookup) last_user_lookup,
max(last_user_update) last_user_update,
sd.name dbname
FROM
sys.dm_db_index_usage_stats, master..sysdatabases sd
WHERE
sd.name not in('master','tempdb','model','msdb')
AND
database_id = sd.dbid group by sd.name
)
SELECT
dbname,
last_read = MAX(last_read),
last_write = MAX(last_write)
FROM
(
SELECT dbname, last_user_seek, NULL FROM agg
UNION ALL
SELECT dbname, last_user_scan, NULL FROM agg
UNION ALL
SELECT dbname, last_user_lookup, NULL FROM agg
UNION ALL
SELECT dbname, NULL, last_user_update FROM agg
) AS x (dbname, last_read, last_write)
GROUP BY
dbname
ORDER BY 1;
&amp;quot;
#Open Excel
$xl = new-object -comobject excel.application
$wb = $xl.Workbooks.Add()
# Load SMO extension
[System.Reflection.Assembly]::LoadWithPartialName(&amp;quot;Microsoft.SqlServer.Smo&amp;quot;) | Out-Null;
# Loop through each sql server from sqlservers.txt
foreach ($sqlserver in $sqlservers) {
# Get the time SQL was restarted
$svr = New-Object 'Microsoft.SQLServer.Management.Smo.Server' $SQLServer
$db = $svr.Databases['TempDB']
$CreateDate = $db.CreateDate
#Run Query against SQL Server
$Results = Invoke-Sqlcmd -ServerInstance $sqlServer -Query $query -Database master
# Add a new sheet
$ws = $wb.Worksheets.Add()
$name = &amp;quot;$sqlserver&amp;quot;
# Name the Sheet
$ws.name = $Name
$cells = $ws.Cells
$xl.Visible = $true
#define some variables to control navigation
$row = 2
$col = 2
$cells.item($row, $col) = $SQLServer + ' Was Rebooted at ' + $CreateDate
$cells.item($row, $col).font.size = 16
$Cells.item($row, $col).Columnwidth = 10
$row = 3
$col = 2
# Set some titles
$cells.item($row, $col) = &amp;quot;Server&amp;quot;
$cells.item($row, $col).font.size = 16
$Cells.item($row, $col).Columnwidth = 10
$col++
$cells.item($row, $col) = &amp;quot;Database&amp;quot;
$cells.item($row, $col).font.size = 16
$Cells.item($row, $col).Columnwidth = 40
$col++
$cells.item($row, $col) = &amp;quot;Last Read&amp;quot;
$cells.item($row, $col).font.size = 16
$Cells.item($row, $col).Columnwidth = 20
$col++
$cells.item($row, $col) = &amp;quot;Last Write&amp;quot;
$cells.item($row, $col).font.size = 16
$Cells.item($row, $col).Columnwidth = 20
$col++
foreach ($result in $results) {
# Check if value is NULL
$DBNull = [System.DBNull]::Value
$LastRead = $Result.last_read
$LastWrite = $Result.last_write
$row++
$col = 2
$cells.item($Row, $col) = $sqlserver
$col++
$cells.item($Row, $col) = $Result.dbname
$col++
if ($LastRead -eq $DBNull) {
$LastRead = &amp;quot;Not Since Last Reboot&amp;quot;
$colour = &amp;quot;46&amp;quot;
$cells.item($Row, $col).Interior.ColorIndex = $colour
$cells.item($Row, $col) = $LastRead
}
else {
$cells.item($Row, $col) = $LastRead
}
$col++
if ($LastWrite -eq $DBNull) {
$LastWrite = &amp;quot;Not Since Last Reboot&amp;quot;
$colour = &amp;quot;46&amp;quot;
$cells.item($Row, $col).Interior.ColorIndex = $colour
$cells.item($Row, $col) = $LastWrite
}
else {
$cells.item($Row, $col) = $LastWrite
}
}
}
$xl.DisplayAlerts = $false
$wb.Saveas($FileName)
$xl.quit()
Stop-Process -Name *excel*
&lt;/code>&lt;/pre>
&lt;p>What it does is place the query in a variable. Get the contents of the SQL Server text file holding all my known SQL Servers and runs the query against each of them storing the results in a variable. It then creates an Excel Workbook and a new sheet for each server and populates the sheet including a bit of colour formatting before saving it. The results look like this&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.robsewell.com/assets/uploads/2014/02/usage-excel.jpg" target="_blank" rel="noopener"
>&lt;img src="https://blog.robsewell.com/assets/uploads/2014/02/usage-excel.jpg"
loading="lazy"
alt="usage excel"
>&lt;/a>&lt;/p>
&lt;p>The tricky bit was understanding how to match the NULL result from the query. This was done by assigning a variable to &lt;code>[System.DBNull]::Value&lt;/code> and using that.&lt;/p>
&lt;p>Of course these stats are reset when SQL Server restarts so I also included the SQL server restart time using the create date property  of the TempDB. I gathered these stats for a few months before starting any rationalisation.&lt;/p>
&lt;p>My next post will be about the next step in the process.&lt;/p></description></item></channel></rss>